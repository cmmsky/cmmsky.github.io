<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="花笺"><title>数据流重定向 · 花笺说</title><meta name="description" content="1ls -l /tmp &amp;gt; /tmp/test.text
ls -l /tmp 所显示的数据已经被重新导向到 /tmp/test.text文件中了.但是

该文件 (本例中是 /tmp/test.text) 若不存在,系统会自动的将他建立起来,但是
当这个文件存在的时候,那么系统就会先将这个文"><meta name="keywords" content="编程 java c c++ php python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">花笺说</a></h3><div class="description"><p>计算机技术学习及分享的博客，内容涉及各类编程语言，java,c,c++,php,python</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">主页</a></li><li><a href="/about">关于</a></li><li><a href="/categories">分类</a></li><li><a href="/archives">归档</a></li><li><a href="/navigation">导航</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>数据流重定向</a></h3></div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /tmp &gt; /tmp/test.text</span><br></pre></td></tr></table></figure>
<p>ls -l /tmp 所显示的数据已经被重新导向到 /tmp/test.text文件中了.但是</p>
<ol>
<li>该文件 (本例中是 /tmp/test.text) 若不存在,系统会自动的将他建立起来,但是</li>
<li>当这个文件存在的时候,那么系统就会先将这个文件内容清空,然后再将数据写入!</li>
<li>也就是若以 &gt; 输出到一个已存在的文件中,那个文件就会被覆盖掉</li>
</ol>
<p>但是&gt;&gt;则不会覆盖原内容，而是以累加的方式也就是追加的形式。</p>
<p> 1&gt; :以覆盖的方法将『正确的数据』输出到指定的文件或装置上;<br> 1&gt;&gt;:以累加的方法将『正确的数据』输出到指定的文件或装置上;<br> 2&gt; :以覆盖的方法将『错误的数据』输出到指定的文件或装置上;<br> 2&gt;&gt;:以累加的方法将『错误的数据』输出到指定的文件或装置上;</p>
<p>『 1&gt;&gt; 』以及『 2&gt;&gt; 』中间是没有空格的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">承范例二,将 stdout 与 stderr 分存到不同的文件去</span><br><span class="line">$ find /home -name .bashrc &gt; list_right 2&gt; list_error</span><br></pre></td></tr></table></figure>
<p>/dev/null 垃圾桶黑洞装置与特殊写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将错误的数据丢弃,屏幕上显示正确的数据</span><br><span class="line">[dmtsai@study ~]$ find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将指令的数据全部写入名为 list 的文件中</span><br><span class="line">[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt; list &lt;==错误</span><br><span class="line">[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1 &lt;==正确</span><br><span class="line">[dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list &lt;==正确</span><br></pre></td></tr></table></figure>
<p>standard input : &lt; 与 &lt;&lt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//用 stdin 取代键盘的输入以建立新文件的简单流程</span><br><span class="line">//将~/.bashrc中的文件内容输入到catfile，并显示在屏幕上</span><br><span class="line">$ cat &gt; catfile &lt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="管线命令-pipe"><a href="#管线命令-pipe" class="headerlink" title="管线命令 (pipe)"></a>管线命令 (pipe)</h4><p>每个管线后面接的第一个数据必定是『指令』    ，而且这个指令必须要能够接受 standard input 的数据才行</p>
<h5 id="撷取命令-cut-grep"><a href="#撷取命令-cut-grep" class="headerlink" title="撷取命令: cut, grep"></a>撷取命令: cut, grep</h5><p>cut</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符</span><br><span class="line">$ cut -c 字符区间			 &lt;==用于排列整齐的讯息</span><br><span class="line">选项与参数:</span><br><span class="line">-d :后面接分隔字符。与 -f 一起使用;</span><br><span class="line">-f :依据 -d 的分隔字符将一段讯息分区成为数段,用 -f 取出第几段的意思;</span><br><span class="line">-c :以字符 (characters) 的单位取出固定字符区间;</span><br><span class="line">//将 PATH 变量取出,我要找出第五个路径。</span><br><span class="line">$ echo $&#123;PATH&#125;</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br><span class="line">$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 5</span><br><span class="line"># 如同上面的数字显示,我们是以『 : 』作为分隔,因此会出现 /home/dmtsai/.local/bin</span><br><span class="line"># 那么如果想要列出第 3 与第 5 呢?,就是这样:</span><br><span class="line">$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 3,5</span><br><span class="line">//将 export 输出的讯息,取得第 12 字符以后的所有字符串</span><br><span class="line">$ export | cut -c 12-</span><br><span class="line">HISTCONTROL=&quot;ignoredups&quot;</span><br><span class="line">HISTSIZE=&quot;1000&quot;</span><br><span class="line">HOME=&quot;/home/dmtsai&quot;</span><br><span class="line">HOSTNAME=&quot;study.centos.vbird&quot;</span><br></pre></td></tr></table></figure>
<p>grep</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class="line">选项与参数:</span><br><span class="line">-a :将 binary 文件以 text 文件的方式搜寻数据</span><br><span class="line">-c :计算找到 &apos;搜寻字符串&apos; 的次数</span><br><span class="line">-i :忽略大小写的不同,所以大小写视为相同</span><br><span class="line">-n :顺便输出行号</span><br><span class="line">-v :反向选择,亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行!</span><br><span class="line">--color=auto :可以将找到的关键词部分加上颜色的显示喔!</span><br><span class="line">//将 last 当中,有出现 root 的那一行就取出来;</span><br><span class="line">$ last | grep &apos;root&apos;</span><br><span class="line">//与范例一相反,只要没有 root 的就取出!</span><br><span class="line">$ last | grep -v &apos;root&apos;</span><br><span class="line">//在 last 的输出讯息中,只要有 root 就取出,并且仅取第一栏</span><br><span class="line">$ last | grep &apos;root&apos; |cut -d &apos; &apos; -f1</span><br></pre></td></tr></table></figure>
<h5 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="排序命令: sort, wc, uniq"></a>排序命令: sort, wc, uniq</h5><p>sort</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">选项与参数:</span><br><span class="line">-f :忽略大小写的差异,例如 A 与 a 视为编码相同;</span><br><span class="line">-b :忽略最前面的空格符部分;</span><br><span class="line">-M :以月份的名字来排序,例如 JAN, DEC 等等的排序方法;</span><br><span class="line">-n :使用『纯数字』进行排序(默认是以文字型态来排序的);</span><br><span class="line">-r :反向排序;</span><br><span class="line">-u :就是 uniq ,相同的数据中,仅出现一行代表;</span><br><span class="line">-t :分隔符,预设是用 [tab] 键来分隔;</span><br><span class="line">-k :以那个区间 (field) 来进行排序的意思</span><br><span class="line">//个人账号都记录在 /etc/passwd 下,请将账号进行排序。</span><br><span class="line">[dmtsai@study ~]$ cat /etc/passwd | sort</span><br><span class="line">abrt:x:173:173::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line"># 鸟哥省略很多的输出~由上面的数据看起来, sort 是预设『以第一个』数据来排序,</span><br><span class="line"># 而且默认是以『文字』型态来排序的喔!所以由 a 开始排到最后啰!</span><br><span class="line">// /etc/passwd 内容是以 : 来分隔的,我想以第三栏来排序</span><br><span class="line">$ cat /etc/passwd | sort -t &apos;:&apos; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line">arod:x:1002:1003::/home/arod:/bin/bash</span><br><span class="line">//利用 last ,将输出的数据仅取账号,并加以排序</span><br><span class="line">$ last | cut -d &apos; &apos; -f1 | sort</span><br></pre></td></tr></table></figure>
<p>uniq</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ uniq [-ic]</span><br><span class="line">选项与参数:</span><br><span class="line">-i :忽略大小写字符的不同;</span><br><span class="line">-c :进行计数</span><br><span class="line">//使用 last 将账号列出,仅取出账号栏,进行排序后仅取出一位;</span><br><span class="line">$ last | cut -d &apos; &apos; -f1 | sort | uniq</span><br><span class="line">//承上题,如果我还想要知道每个人的登入总次数呢?</span><br><span class="line">$ last | cut -d &apos; &apos; -f1 | sort | uniq -c</span><br></pre></td></tr></table></figure>
<p>wc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wc [-lwm]</span><br><span class="line">选项与参数:</span><br><span class="line">-l :仅列出行;</span><br><span class="line">-w :仅列出多少字(英文单字);</span><br><span class="line">-m :多少字符;</span><br><span class="line">那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数?</span><br><span class="line">[dmtsai@study ~]$ cat /etc/man_db.conf | wc</span><br><span class="line">131	723	5171</span><br><span class="line"># 输出的三个数字中,分别代表: 『行、字数、字符数』</span><br></pre></td></tr></table></figure>
<p>tee（双向重定向）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tee [-a] file</span><br><span class="line">选项与参数:</span><br><span class="line">-a :以累加 (append) 的方式,将数据加入 file 当中!</span><br><span class="line">$ last | tee last.list | cut -d &quot; &quot; -f1</span><br><span class="line"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中</span><br><span class="line">$ ls -l /home | tee ~/homefile | more</span><br><span class="line"># 这个范例则是将 ls 的数据存一份到 ~/homefile ,同时屏幕也有输出讯息!</span><br><span class="line">$ ls -l / | tee -a ~/homefile | more</span><br><span class="line"># 要注意! tee 后接的文件会被覆盖,若加上 -a 这个选项则能将讯息累加</span><br></pre></td></tr></table></figure>
<h5 id="字符转换命令-tr-col-join-paste-expand"><a href="#字符转换命令-tr-col-join-paste-expand" class="headerlink" title="字符转换命令: tr, col, join, paste, expand"></a>字符转换命令: tr, col, join, paste, expand</h5><p>tr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tr [-ds] SET1 ...</span><br><span class="line">选项与参数:</span><br><span class="line">-d :删除讯息当中的 SET1 这个字符串;</span><br><span class="line">-s :取代掉重复的字符!</span><br><span class="line">//将 last 输出的讯息中,所有的小写变成大写字符:</span><br><span class="line">$ last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class="line"># 事实上,没有加上单引号也是可以执行的,如:『 last | tr [a-z] [A-Z] 』</span><br><span class="line">//将 /etc/passwd 输出的讯息中,将冒号 (:) 删除</span><br><span class="line">$ cat /etc/passwd | tr -d &apos;:&apos;</span><br></pre></td></tr></table></figure>
<p>col</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ col [-xb]</span><br><span class="line">选项与参数:</span><br><span class="line">-x:将 tab 键转换成对等的空格键</span><br><span class="line">//利用 cat -A 显示出所有特殊按键,最后以 col 将 [tab] 转成空白</span><br><span class="line">$ cat -A /etc/man_db.conf	&lt;==此时会看到很多 ^I 的符号,那就是 tab</span><br><span class="line">$ cat /etc/man_db.conf | col -x | cat -A | more</span><br><span class="line"># 嘿嘿!如此一来, [tab] 按键会被取代成为空格键,输出就美观多了!</span><br></pre></td></tr></table></figure>
<p>join</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ join [-ti12] file1 file2</span><br><span class="line">选项与参数:</span><br><span class="line">-t:join 默认以空格符分隔数据,并且比对『第一个字段』的数据,</span><br><span class="line">如果两个文件相同,则将两笔数据联成一行,且第一个字段放在第一个!</span><br><span class="line">-i :忽略大小写的差异;</span><br><span class="line">-1 :这个是数字的 1 ,代表『第一个文件要用那个字段来分析』的意思;</span><br><span class="line">-2 :代表『第二个文件要用那个字段来分析』的意思。</span><br><span class="line">//用 root 的身份,将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span><br><span class="line">[root@study ~]# head -n 3 /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure>
<p>paste<br>这个 paste 就要比 join 简单多了!相对于 join 必须要比对两个文件的数据相关性, paste 就直接<br>『将两行贴在一起,且中间以 [tab] 键隔开』而已!简单的使用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ paste [-d] file1 file2</span><br><span class="line">选项与参数:</span><br><span class="line">-d :后面可以接分隔字符。预设是以 [tab] 来分隔的!</span><br><span class="line">- :如果 file 部分写成 - ,表示来自 standard input 的资料的意思。</span><br><span class="line">//用 root 身份,将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span><br><span class="line"># paste /etc/passwd /etc/shadow</span><br><span class="line">root:x:0:0:root:/root:/bin/bash root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">bin:*:16372:0:99999:7:::</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:16372:0:99999:7:::</span><br><span class="line"># 注意喔!同一行中间是以 [tab] 按键隔开的!</span><br><span class="line">//先将 /etc/group 读出(用 cat),然后与范例一贴上一起!且仅取出前三行</span><br><span class="line"># cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3</span><br><span class="line"># 这个例子的重点在那个 - 的使用!那玩意儿常常代表 stdin 喔!</span><br></pre></td></tr></table></figure>
<p>expand</p>
<p>这玩意儿就是在将 [tab] 按键转成空格键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ expand [-t] file</span><br><span class="line">选项与参数:</span><br><span class="line">-t:后面可以接数字。一般来说,一个 tab 按键可以用 8 个空格键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢!</span><br><span class="line">将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出;仅取前三行;</span><br><span class="line">$ grep &apos;^MANPATH&apos; /etc/man_db.conf | head -n 3</span><br><span class="line">MANPATH_MAP /bin /usr/share/man</span><br><span class="line">MANPATH_MAP /usr/bin /usr/share/man</span><br><span class="line">MANPATH_MAP /sbin /usr/share/man</span><br><span class="line"># 行首的代表标志为 ^ ,这个我们留待下节介绍!先有概念即可!</span><br><span class="line">我将 [tab] 按键设定成 6 个字符的话?</span><br><span class="line">[dmtsai@study ~]$ grep &apos;^MANPATH&apos; /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A</span><br><span class="line">MANPATH_MAP /bin /usr/share/man$</span><br><span class="line">MANPATH_MAP /usr/bin /usr/share/man$</span><br><span class="line">MANPATH_MAP /sbin /usr/share/man$</span><br></pre></td></tr></table></figure>
<h5 id="分区命令-split"><a href="#分区命令-split" class="headerlink" title="分区命令: split"></a>分区命令: split</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span><br><span class="line">选项与参数:</span><br><span class="line">-b :后面可接欲分区成的文件大小,可加单位,例如 b, k, m 等;</span><br><span class="line">-l :以行数来进行分区。</span><br><span class="line">PREFIX :代表前导符的意思,可作为分区文件的前导文字。</span><br><span class="line">//我的 /etc/services 有六百多 K,若想要分成 300K 一个文件时</span><br><span class="line">$ cd /tmp; split -b 300k /etc/services services</span><br><span class="line">$ ll -k services*</span><br><span class="line">-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesaa</span><br><span class="line">-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesab</span><br><span class="line">-rw-rw-r--. 1 dmtsai dmtsai 9 22:52 servicesac</span><br><span class="line">55893 Jul</span><br><span class="line"># 那个档名可以随意取的啦!我们只要写上前导文字,小文件就会以</span><br><span class="line"># xxxaa, xxxab, xxxac 等方式来建立小文件的!</span><br><span class="line">如何将上面的三个小文件合成一个文件,档名为 servicesback</span><br><span class="line">$ cat services* &gt;&gt; servicesback</span><br><span class="line"># 很简单吧?就用数据流重导向就好啦!简单!</span><br></pre></td></tr></table></figure>
<h5 id="参数代换-xargs"><a href="#参数代换-xargs" class="headerlink" title="参数代换: xargs"></a>参数代换: xargs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ xargs [-0epn] command</span><br><span class="line">选项与参数:</span><br><span class="line">-0:如果输入的 stdin 含有特殊字符,例如 `, \, 空格键等等字符时,这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔!</span><br><span class="line">-e:这个是 EOF (end of file) 的意思。后面可以接一个字符串,当 xargs 分析到这个字符串时,就会停止继续工作!</span><br><span class="line">-p :在执行每个指令的 argument 时,都会询问使用者的意思;</span><br><span class="line">-n :后面接次数,每次 command 指令执行时,要使用几个参数的意思。</span><br><span class="line">当 xargs 后面没有接任何的指令时,默认是以 echo 来进行输出喔!</span><br><span class="line">#将 /etc/passwd 内的第一栏取出,仅取三行,使用 id 这个指令将每个账号内容秀出来</span><br><span class="line">$ id root</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)	# 这个 id 指令可以查询用户的 UID/GID 等信息</span><br><span class="line">$ id $(cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3)</span><br><span class="line"># 虽然使用 $(cmd) 可以预先取得参数,但可惜的是, id 这个指令『仅』能接受一个参数而已!</span><br><span class="line"># 所以上述的这个指令执行会出现错误!根本不会显示用户的 ID 啊</span><br><span class="line">$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | id</span><br><span class="line"># 因为 id 并不是管线命令,因此在上面这个指令执行后,前面的东西通通不见!只会执行 id!</span><br><span class="line"></span><br><span class="line">//正确处理方式</span><br><span class="line">$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -n 1 id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">uid=1(bin) gid=1(bin) groups=1(bin)</span><br><span class="line">uid=2(daemon) gid=2(daemon) groups=2(daemon)</span><br><span class="line"># 透过 -n 来处理,一次给予一个参数,因此上述的结果就 OK 正常的显示啰!</span><br><span class="line">同上,但是每次执行 id 时,都要询问使用者是否动作?</span><br><span class="line">$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id</span><br><span class="line">id root ?...y</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">id bin ?...y</span><br></pre></td></tr></table></figure>
<h5 id="关于减号-的用途"><a href="#关于减号-的用途" class="headerlink" title="关于减号 - 的用途"></a>关于减号 - 的用途</h5><p>在管线命令当中,常常会使用到前一个指令的 stdout 作为这次的stdin,某些指令需要用到文件名 (例如 tar) 来进行处理时.该 stdin 与 stdout 可以利用减号 “-“来替代.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /tmp/homeback</span><br><span class="line"># tar -cvf - /home | tar -xvf - -C /tmp/homeback</span><br><span class="line">上面这个例子是说:『我将 /home 里面的文件给他打包,但打包的数据不是纪录到文件,而是传送</span><br><span class="line">到 stdout; 经过管线后,将 tar -cvf - /home 传送给后面的 tar -xvf - 』。后面的这个 - 则是取用前</span><br><span class="line">一个指令的 stdout, 因此,我们就不需要使用 filename</span><br></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-02</span><i class="fa fa-tag"></i><a class="tag" href="/categories/linux/" title="linux">linux </a><a class="tag" href="/tags/linux/" title="linux">linux </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://huajian.skydinary.com/2018/09/02/数据流重定向/,花笺说,数据流重定向,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/09/03/shell-scripts/" title="shell_scripts">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/08/29/linux运维/" title="Linux运维">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>